// This file is auto-generated by @hey-api/openapi-ts

export type LoginResponse = {
    code: number;
    message: string;
    data: {
        token: string;
    };
};

/**
 * Telegram Chat Takeout Schema
 * Schema for Telegram chat takeout data, including messages and chat information.
 */
export type TelegramResult = {
    /**
     * Name of the chat (e.g., channel name, group name, or contact name).
     */
    name: string;
    /**
     * Type of the chat (e.g., 'public_channel', 'private_chat', 'bot_chat', 'private_channel', 'supergroup').
     */
    type: 'public_channel' | 'private_chat' | 'bot_chat' | 'private_channel' | 'supergroup';
    /**
     * Unique identifier for the chat.
     */
    id: number;
    /**
     * List of messages in the chat.
     */
    messages: Array<{
        /**
         * Unique identifier for the message.
         */
        id: number;
        /**
         * Type of the message (e.g., 'message', 'service').
         */
        type: 'message' | 'service';
        /**
         * Date and time when the message was sent in ISO 8601 format.
         */
        date: string;
        /**
         * Date and time when the message was sent in Unix timestamp format (string representation).
         */
        date_unixtime: string;
        /**
         * Name of the actor performing a service action (e.g., channel name, user name).
         */
        actor?: string;
        /**
         * ID of the actor performing a service action (e.g., 'channel<id>', 'user<id>').
         */
        actor_id?: string;
        /**
         * Type of service action (e.g., 'create_channel', 'group_call_scheduled', 'group_call').
         */
        action?: string;
        /**
         * Title of the chat, relevant for 'create_channel' service messages.
         */
        title?: string;
        /**
         * Name of the sender.
         */
        from?: string;
        /**
         * ID of the sender (e.g., 'channel<id>', 'user<id>').
         */
        from_id?: string;
        /**
         * Path to the attached file.
         */
        file?: string;
        /**
         * Original name of the attached file.
         */
        file_name?: string;
        /**
         * Size of the attached file in bytes.
         */
        file_size?: number;
        /**
         * MIME type of the attached file.
         */
        mime_type?: string;
        /**
         * Path to the thumbnail file.
         */
        thumbnail?: string;
        /**
         * Size of the thumbnail file in bytes.
         */
        thumbnail_file_size?: number;
        /**
         * Path to the photo file.
         */
        photo?: string;
        /**
         * Size of the photo file in bytes.
         */
        photo_file_size?: number;
        /**
         * Width of the media (photo, video, sticker, animation).
         */
        width?: number;
        /**
         * Height of the media (photo, video, sticker, animation).
         */
        height?: number;
        /**
         * Specific type of media (e.g., 'video_file', 'voice_message', 'sticker', 'animation').
         */
        media_type?: string;
        /**
         * Duration of the media in seconds (video, voice_message, animation).
         */
        duration_seconds?: number;
        /**
         * Emoji associated with the sticker.
         */
        sticker_emoji?: string;
        /**
         * Indicates if the media is hidden behind a spoiler.
         */
        media_spoiler?: boolean;
        /**
         * Details of a poll.
         */
        poll?: {
            /**
             * The question of the poll.
             */
            question: string;
            /**
             * Indicates if the poll is closed.
             */
            closed: boolean;
            /**
             * Total number of voters in the poll.
             */
            total_voters: number;
            answers: Array<{
                /**
                 * Text of the answer option.
                 */
                text: string;
                /**
                 * Number of voters for this answer option.
                 */
                voters: number;
                /**
                 * Indicates if the current user chose this answer.
                 */
                chosen: boolean;
            }>;
        };
        /**
         * Geographical location information.
         */
        location_information?: {
            /**
             * Latitude of the location.
             */
            latitude: number;
            /**
             * Longitude of the location.
             */
            longitude: number;
        };
        /**
         * Unix timestamp of the scheduled date, for 'group_call_scheduled' service messages.
         */
        schedule_date?: number;
        /**
         * Duration of a group call in seconds, for 'group_call' service messages.
         */
        duration?: number;
        text: string | Array<string | unknown>;
        /**
         * List of text entities (e.g., bold, italic, links).
         */
        text_entities: Array<TelegramTextEntity>;
    }>;
};

/**
 * Telegram Text Entity Schema
 * Schema for a single Telegram text entity, representing a formatted part of a message.
 */
export type TelegramTextEntity = {
    /**
     * Type of the text entity (e.g., 'plain', 'bold', 'italic', 'underline', 'strikethrough', 'text_link', 'spoiler', 'pre', 'blockquote', 'code', 'mention', 'phone', 'email', 'cashtag', 'bot_command', 'hashtag', 'url').
     */
    type: 'plain' | 'bold' | 'italic' | 'underline' | 'strikethrough' | 'text_link' | 'spoiler' | 'pre' | 'blockquote' | 'code' | 'mention' | 'phone' | 'email' | 'cashtag' | 'bot_command' | 'hashtag' | 'url';
    /**
     * The text content of the entity.
     */
    text: string;
    /**
     * URL for 'text_link' entities.
     */
    href?: string;
    /**
     * Programming language for 'pre' (code block) entities.
     */
    language?: string;
    /**
     * Indicates if a 'blockquote' is collapsed.
     */
    collapsed?: boolean;
};

export type ApiResult = {
    code: number;
    message: string;
    data: string | number | boolean | Array<unknown> | {
        [key: string]: unknown;
    } | number | null;
};

export type PostAuthLoginData = {
    body?: {
        username: string;
        password: string;
    };
    path?: never;
    query?: never;
    url: '/auth/login';
};

export type PostAuthLoginResponses = {
    200: {
        code: number;
        message: string;
        data: {
            token: string;
        };
    };
};

export type PostAuthLoginResponse = PostAuthLoginResponses[keyof PostAuthLoginResponses];

export type PostDataImportLocalData = {
    body?: {
        /**
         * Local file path
         */
        path: string;
    };
    path?: never;
    query?: never;
    url: '/data/import/local';
};

export type PostDataImportLocalResponses = {
    200: {
        [key: string]: unknown;
    };
};

export type PostDataImportLocalResponse = PostDataImportLocalResponses[keyof PostDataImportLocalResponses];

export type PostDataImportUploadData = {
    body?: {
        file?: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/data/import/upload';
};

export type PostDataImportUploadResponses = {
    200: {
        [key: string]: unknown;
    };
};

export type PostDataImportUploadResponse = PostDataImportUploadResponses[keyof PostDataImportUploadResponses];

export type ClientOptions = {
    baseUrl: string;
};